//
// Created by HORIA on 29.12.2023.
//

#include "Menu.h"
#include <ios>
#include <algorithm>

Menu* Menu::m_menu = nullptr;

Menu* Menu::get_instance() {
    if (!m_menu) {
        return new Menu;
    }
    return m_menu;
}

void Menu::free_instance() {
    delete m_menu;
    m_menu = nullptr;
}

bool Menu::get_state() const {return m_on;}

void Menu::display_main() {
    std::cout << "1. Adauga Calculator\n"
                 "2. Afiseaza Calculatore\n"
                 "3. Acceseaza calculator\n"
                 "Any other option closes the program\n"
                 "-----------------------------------\n";
    main_menu_funcionality();
}

void Menu::main_menu_funcionality() {
    int opt {};
    std::cout << "Introdu optiune: ";
    std::cin >> opt;
    std::cout << '\n';
    switch (opt) {
        case 1: {
            add_computer();
            break;
        }
        case 2: {
            display_computers();
            break;
        }
        case 3: {
            display_second_menu();
            side_menu_functionality();
            break;
        }
        default: {
            m_on = false;
            break;
        }
    }
}

void Menu::add_computer() {
    m_computers.push_back(Computer {});
}

void Menu::display_computers() {
    std::for_each(m_computers.begin(), m_computers.end(),[](const Computer& obj){
        std::cout << obj;
    });
}

std::list<Computer>::iterator Menu::acces_computer() {
    std::cout << "Introdu id calc: ";
    int id{-1};
    std::cin >> id;
    std::cout << '\n';
    return std::find_if(m_computers.begin(), m_computers.end(),[id](auto it){
        return it.get_unique_id()==id;
    });
}

void Menu::display_second_menu() {
    std::cout << "1. Afisare Calculator\n"
                 "2. Introducere tip malware\n"
                 "Orice alta optiune este back\n"
                 "--------------------------------\n";
}

void Menu::side_menu_functionality() {
    auto pc {acces_computer()};
    if (pc == m_computers.end()) {
        std::cout << "Invalid id!\n";
        return;
    }
    display_second_menu();
    int calc_opt{};
    std::cout << "Introdu opt: ";
    std::cin >> calc_opt;
    std::cout << '\n';
    switch (calc_opt) {
        case 1: {
            std::cout << *pc;
            break;
        }
        case 2: {
            std::cout << "1.RootKit\n2.Keylogger\n3.KernelyKeylogger\n4.Ransomware\n";
            std::cout << "opt: ";
            int opt {-1};
            std::cin >> opt;
            std::cout << '\n';
            if (get_malware_type(opt) != MalwareTypes::Invalid) {
                auto malware {MalwareFactory::create_malware(get_malware_type(opt))};
                //std::cin >> malware;
                pc->add_malware(malware);
                pc->update_final_rating();
            } else {
                std::cout << "Invalid malware type id!\n";
            }
        }
        default: {
            break;
        }
    }
}

MalwareTypes Menu::get_malware_type(int opt) {
    switch (opt) {
        case 1: return MalwareTypes::RootKit;
        case 2: return MalwareTypes::Keylogger;
        case 3: return MalwareTypes::KernelKeylogger;
        case 4: return MalwareTypes::Ransomware;
        default:
            return MalwareTypes::Invalid;
    }
}
